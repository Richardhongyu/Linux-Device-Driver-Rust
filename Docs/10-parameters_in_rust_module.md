# Parameters in Rust Module

## `make_param_ops!( )` macro

This macro is defined in file: `rust/kernel/module_param.rs`:

```rust
macro_rules! make_param_ops {
    ($ops:ident, $ty:ty) => {
        $crate::make_param_ops!(
            #[doc=""]
            $ops,
            $ty
        );
    };
    ($(#[$meta:meta])* $ops:ident, $ty:ty) => {
        $(#[$meta])*
        ///
        /// Static [`kernel_param_ops`](../../../include/linux/moduleparam.h)
        /// struct generated by [`make_param_ops`].
        pub static $ops: $crate::bindings::kernel_param_ops = $crate::bindings::kernel_param_ops {
            flags: if <$ty as $crate::module_param::ModuleParam>::NOARG_ALLOWED {
                $crate::bindings::KERNEL_PARAM_OPS_FL_NOARG
            } else {
                0
            },
            set: Some(<$ty as $crate::module_param::ModuleParam>::set_param),
            get: Some(<$ty as $crate::module_param::ModuleParam>::get_param),
            free: Some(<$ty as $crate::module_param::ModuleParam>::free),
        };
    };
}
```

This is a declarative macro in Rust.

## Declarative macro

Previously, we introduced procedual macro which is used to define `module!{ }`.

Parameters definition is kernel are benenifits from declarative macro. The
declarative macro is simpler than procedual macro. Basically, it is has a
profile like `match` expression:

```rust
macro_rules! make_param_ops {
    ($ops:ident, $ty:ty) => {
        ...
    };
    ($(#[$meta:meta])* $ops:ident, $ty:ty) => {
        ...
    };
}
```

Declarative macro starts with the keyword `macro_rules!` and follows the name
of macro, i.e. `make_param_ops`. The code block in macro definition is similar
to `match` expression that to match arms are defined. However, instead of
matching values of variables, the match arm for macro definition matches
token it receives.

The first arm `($ops:ident, $ty:ty) => { }` matches two tokens in its paramters
(using word parameter seem not very precise). The first must be an indetifier,
and the second must be a type.

The second arm `($(#[$meta:meta])* $ops:ident, $ty:ty) => { }` matches three
tokens in its paramters: a meta item, an indetifier and a type.

Macro takes these indetifiers, types, or other token types, like statement, item,
expression, and then create new rust code based on these tokens.

## `make_param_ops!( )` macro expansion

To define module paramter with type u32:

```rust
make_param_ops!(
    PARAM_OPS_U32,      // Name for the static
    u32                 // A type which implements [`ModuleParam`].
);
```

Psses two tokens to `make_param_ops!()` macro, and matches the first match arm:

```rust
($ops:ident, $ty:ty) => {
    $crate::make_param_ops!(
        #[doc=""]
        $ops,
        $ty
    );
};
```

In this code block, `make_param_ops!( )` is invoked again and passed in three
tokens: `#[doc=""]`, `$ops`, `$ty`. The later two are parameters received from
macro invocation. Then this macro is recursively expaned to:

```rust
make_param_ops!(
    #[doc=""],
    PARAM_OPS_U32,      // Name for the static
    u32                 // A type which implements [`ModuleParam`].
);
```

This time, the second match arm is selected and the marco is expaned to:

```rust
pub static PARAM_OPS_U32: crate::bindings::kernel_param_ops = crate::bindings::kernel_param_ops {
    flags: if <u32 as crate::module_param::ModuleParam>::NOARG_ALLOWED {
        crate::bindings::KERNEL_PARAM_OPS_FL_NOARG
    } else {
        0
    },
    set: Some(<u32 as crate::module_param::ModuleParam>::set_param),
    get: Some(<u32 as crate::module_param::ModuleParam>::get_param),
    free: Some(<u32 as crate::module_param::ModuleParam>::free),
};
```

This structure is assgined to `ops` field of `kernel_param`:

```rust
#[link_section = "__param"]
#[used]
static __example_module_uint_param_struct: __example_module_uint_param_RacyKernelParam =
    __example_module_uint_param_RacyKernelParam(kernel::bindings::kernel_param {
        name: __example_module_uint_param_name,

    #[cfg(MODULE)]
    mod_: unsafe { &kernel::bindings::__this_module as *const _ as *mut _ },
    ops: unsafe { &kernel::module_param::PARAM_OPS_U32 }
        as *const kernel::bindings::kernel_param_ops,
    perm: 0o644,
    level: -1,
    flags: 0,
    __bindgen_anon_1: kernel::bindings::kernel_param__bindgen_ty_1 {
        arg: unsafe { &__example_module_uint_param_value } as *const _
            as *mut kernel::c_types::c_void,
    },
});
```

And finially be placed in `__param` section.
